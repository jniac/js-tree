<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

<script type="module">

function bench(...functions) {

	const now = typeof performance === 'object' 
		? performance.now.bind(performance)
		: Date.now.bind(Date)

	console.log(`\ntest bench of ${functions.length} functions`)
	
	let { duration, costPrecision } = bench
	
	let t, dt, count, cost

	t = now()
	count = 0

	while(now() - t < duration)
		count++

	dt = now() - t
	cost = dt / count
	console.log(`-- dt: ${dt.toFixed(1)}ms count: ${count}op cost: ${cost.toFixed(costPrecision)}ms`)

	let refCount = count

	for (let [i, f] of functions.entries()) {

		t = now()
		count = 0

		while(now() - t < duration) {

			f()
			count++

		}

		dt = now() - t
		cost = dt / count

		let relCost = refCount / count

		if (f.name)
			console.log(f.name + ':')

		console.log(`#${i} dt: ${dt.toFixed(1)}ms count: ${bench.formatBigNumber(count)}op cost: ${cost.toFixed(costPrecision)}ms x${relCost.toFixed(3)} slower`)

	}
	
}

Object.assign(bench, {

	duration: 500, 		// ms
	costPrecision: 6, 	// digit in output
	formatBigNumber: (n, { precision = 0, separator = ','} = {}) => n.toFixed().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + separator),
	
})







let NodeUID = 0

class Node {

	constructor() {

		this.uid = NodeUID++
		this.children = []

	}

	get level() { return this.parent ? this.parent.level + 1 : 0 }

	append(...nodes) {

		this.children.push(...nodes)

		for (let node of nodes)
			node.parent = this

		return this

	}

	getAllChildren() {

		let array = []

		for (let i = 0, node; node = this.children[i]; i++) {

			array.push(node)
			array = array.concat(node.getAllChildren())

		}

		return array

	}

	*forAllChildren() {

		for (let i = 0, node; node = this.children[i]; i++) {

			yield node

			for (let node2 of node.forAllChildren())
				yield node2

		}

	}

	allChildrenCallback(callback) {

		callback(this)

		for (let i = 0, node; node = this.children[i]; i++)
			node.allChildrenCallback(callback)

	}

	line() {

		return '  '.repeat(this.level) + 'node #' + this.uid
	}

	print() {

		for (let node of this.getAllChildren())
			console.log(node.line())

	}

}

let node = new Node().append(new Node(), new Node().append(new Node(), new Node(), new Node().append(new Node())), new Node(), new Node().append(new Node(), new Node(), new Node()))

console.log(node.print())

console.log('\narray')
for (let child of node.getAllChildren())
	console.log(child.line())

console.log('\niterator')
for (let child of node.forAllChildren())
	console.log(child.line())

console.log('\ncallback')
node.allChildrenCallback(child => console.log(child.line()))

bench(function arrayForOf() {

	for (let child of node.getAllChildren())
		node.random = Math.random()

}, function iterators() {

	for (let child of node.forAllChildren())
		node.random = Math.random()

}, function useCallback() {
	
	node.allChildrenCallback(child => node.random = Math.random())

})

</script>

<p>callbacks perform faster iteration over array or iterators (way more faster!)</p>

</body>
</html>